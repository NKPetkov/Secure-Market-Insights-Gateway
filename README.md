# Secure-Market-Insights-Gateway

# Structure
1. Fethcer -> Service B. Microservice responsible for calling the API for the cryptocurrency data
2. Gateway -> Service A. Entry point to the whole system and responsible for auth, caching and rate limiting

I chose to go with syncronous code because FastAPI handles the requests async and there is no need for the endpoints themselves to be async since there are no big requests that take a lot of time or compute and have to be done in the background.
I chose to use redis because it is lightweight, super fast, has integrated ttl timeout for data.

# REDIS
The data is structured in two different types key value pairs.
1. Request ID (generated by the gateway service) and the responce from the Fethcer API (used by the GET request of the Gateway API)
2. Query params and Request ID for the POST request of the Gateway API to be able to use the caching instead of having to make a brand new request

# DOCKER
1. Fethcer -> one container handling the service open on port 8000, in a local network between Fethcer and Gateway
2. Redis -> separate container for single principle maintainability, separability of services (for security) etc.
3. Gateway -> one container handling the service open on port 8001, Open to the internet. THe service responcible for handling cache, interacting with Fetcher, rare limiting, auth.
There are requirement.txt and requirements-test.txt with all the packages needed for the services
For more info check DOCKER_SETUP.md

# FETCHER
Structure
- app

- - Dependencies

- - - Logger
Uses the logger python package. Single instance of the logger package that is used accros the service (Semi-singleton pattern)

- - - Input data validator
Checks if the input of the endpoint (symbol name). The acceptable data is a dictionary, keys -> acceptable name of the crypto, values -> ID of the crypto in the CoinMarketCap API.
I used a dictionary of faster implementation. In a production environment upon init of the service and on equal intervals of time (once a day for example) a request for a map of the names of the cryptos and their IDs should be made to keep the service validation up to date with the external API.

- - - CoinMarketCap Client
I used CoinMarketCap instead of the required CoinGecko because CoinGecko now require approval to use their API for free and the CoinMarketCap API is still free of charge for personal projects.
The request still retrives the metadata for a cryptocurrency (eg. symbol, name, category, description, launch date, logo, platform it was developed on, supply in circulation and market cap).
One disadvantage of the CoinMarketCap API is that it has missing data on some of the parameters for some of the cryptos.

- - Routers
I split the requests in separate routers (health & fetch) for readability and maintainability
Also I haven't implemented any auth or rate limiting because the API is open only to the Gateway service and not to the general internet via Docker and the gateway handles all of that.

- - - Health
Basic ping type healthckeck

- - - Fetch
Endpoint that validates the inputed symbol and calls the CoinMarketCap client to fetch the crypto metadata

- - config.py
Unified object for the settings of the service and the ENV variables.
Autoloads them from the .env file via SettingsConfigDict. I only had to get the absolute path of the .env file because it didn't find it by itself

- - models.py
Single place for all the pydantic data models for the health check and crypto metadata endpoints output.
The input data I handled in the endpoints themselves because there was only one input param for the two endpoints.
But in a production environment the input data should also be in models for mainteinability.
Also the models.py structure can be scaled by making the file into a folder and having all the models for a specific endpoint of router in a file

- - main.py
The FastAPI instance. Adding of the routers. General Error 500 error handler. And a lifecicle currently for logs but in the future the fetching of the map of crypto names and IDs from COinMarketCap can be put there for example

- tests
All the unit and integration tests.
Testing the models, the validator, the CoinMarketCap client and request, the endpoints themselves as a whole and the config

# GATEWAY
Structure

- app

- - Dependencies

- - - Auth
Basic authentication with a Bearer token. Initially a did it with a decorator which is the cleaner way. But I decided to change it to a header parameter so it can be used in the Swagger docs which I decided to use as a frontend.
It validates if there is a tiken passed, if the scheme of the header is correct, if the token is the same as the one inputed in the ENV variable

- - - Cache
Uses redis and has the option to set the key value pairs explined in the beginning of the file. Also to delete a specific piece of cache if needed, to clean the whole cahche, to fetch a cached responce by the query params or by the request ID. The cleaning up of the cache is handled by the Redis functionality and the ttl is 10 mins.
A authentic singleton class that handles the caching to prevent unnecessary connections to redis and mixups with the cache. IN production the connection should be a pool instead of a single one to be able to handle the load and have redundancy

- - - Fetcher Handler
The file hosting the client communication with the Fetcher API

- - - Logger
The exact same architecture as in the Fetcher API

- - - Rate Limiter
A decorator that cahces in-memory (another option was to put it in Redis). It has default values from the EVN variables, but it also supports the passing of personal max requests and time frame for an endpoint.
It cleans the previous logged calls before checking if the limit is exeded. In production this can be handled via Redis (with the automatic expiration of entries) or with a service that cleans the cached calls.
The rate limiter logs the private calls using the Bearer token and the public calls (Like the health check) logs using the IP address se there is a rate limit available for every endpoint.

- - - Validator
Copied from the Fethcer API for quicker implementation.

- - Routes
Again separated the Health (GET) endpoint from the ones handling the Insights (GET & POST) for readability and maintainability

- - - Health
The health check endpoint check if the service is good and also if the Redis is alive

- - - Insights
Handling the POST for fetching the metadata and the cache (caching and retrieving the cache). And the GET request fetching directly from the cache by request ID

- - Config
Again the same as the Fetcher service

- - Main
The same as in the Fethcer API. The only new thing is that there is a health check on redis in the lifecycle of FastAPI before initialising the API itself

- - Models
All of the input and output data pydantic models. The crypto insight response in a nested model spliting the cryptocurrency metadata into one model and the request specific data onto another because the crypto metadata can be used elsewhere in he service

- Tests
The same set up as in the Fetcher API but adding the rate limiter and auth